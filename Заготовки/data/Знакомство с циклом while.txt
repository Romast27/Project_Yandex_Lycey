Цикл while
Сегодня мы научимся повторять заданные действия несколько раз. Для этого существуют операторы циклов. Мы разберем оператор цикла while. Он выполняет блок кода, пока истинно какое-то условие.
Напомним, условный оператор if проверяет условие и, в зависимости от того, истинно оно или ложно, выполняет либо не выполняет следующий записанный с отступом блок. После этого программа в любом случае выполняется дальше (там еще может быть elif или else, но сути это не меняет).
1. Цикл while
Оператор while («пока») тоже проверяет условие и тоже, в случае его истинности, выполняет следующий блок кода (тело цикла). Однако после выполнения этого блока кода выполняется не то, что идет после него, а снова проверяется условие, записанное после while.
Ведь при выполнении тела цикла значения каких-то переменных могли измениться — в результате условие цикла может уже не быть истинным. Если условие все еще истинно, тело цикла выполняется снова. Как только условие цикла перестало выполняться (в том числе если оно с самого начала не было выполнено), программа идёт дальше — выполняются команды, записанные после тела цикла.
Условие цикла записывается, как и для if: с помощью операций отношения (>, >=, <, <=, !=, ==). Cложные условия можно составлять с помощью логических операций not, and, or.
Действия, расположенные в теле цикла (блок кода), записываются со смещением вправо на четыре пробела относительно начала слова while. Переменные, входящие в условие, должны на момент проверки условия цикла иметь значения.

while условие:
    блок кода (тело цикла)

Важно!Один шаг цикла (выполнение тела цикла) еще называют итерацией.
Используйте цикл while всегда, когда какая-то часть кода должна выполниться несколько раз, причем невозможно заранее сказать, сколько именно.
Давайте посмотрим программу, в которой цикл будет выполняться, пока не введут число, меньшее или равное 0:

number = int(input())
while number > 0:
    print('Вы ввели положительное число! Вводите дальше.')
    number = int(input())
    print('Так-так, что тут у нас...')
print('Вы ввели отрицательное число или ноль. Всё.')

Разберемся, как будет работать эта программа.
Сначала выполняется первая строчка: number = int(input()) — пользователь вводит целое число. (Мы предполагаем, что пользователь действительно ввел число, и программа не вылетела с ошибкой.) Предположим, он ввел число 10. Оно записано в переменной number.
Выполняется вторая строчка: while number > 0: — «пока number > 0» — здесь проверяется, выполнено ли условие number > 0. Поскольку мы предположили, что number в этот момент равно 10, тогда условие выполнено, поэтому дальше выполняется блок, записанный с отступом, — тело цикла.
Третья строчка программы выводит на экран строку, тут все понятно.
Четвертая строчка вновь считывает с клавиатуры число и сохраняет его в переменную number. Пусть пользователь ввел 2.
Когда выполнение программы доходит до конца тела цикла, происходит возврат к заголовку цикла (второй строчке программы) и повторная проверка условия. Поскольку 2 > 0, снова выполняется тело цикла.
Третья строчка снова выводит на экран сообщение, четвертая строчка снова считывает число (пусть это будет число 3), пятая строчка снова выводит на экран сообщение...
Закончив тело цикла, опять проверяем условие в заголовке. number равно 3, 3 > 0, поэтому продолжаем.
Третья строчка опять выводит на экран сообщение, четвертая строчка опять считывает число. Пусть теперь это будет −1. Обратите внимание: переменная number на каждой итерации цикла приобретает новое значение! Пятая строчка опять выводит на экран сообщение...
Вновь вернувшись на вторую строчку, получаем, что −1 > 0 — ложно. Поэтому цикл завершается, тело цикла больше не выполняется, прыгаем сразу на следующую после цикла строчку программы — шестую. Она выводит последнее сообщение.
Все.

2. Составной оператор присваивания
Напомним, что в операторе присваивания одно и то же имя переменной может стоять и справа (в составе какого-то выражения), и слева. В этом случае сначала вычисляется правая часть со старым значением переменной, после чего результат становится новым значением этой переменной. Ни в коем случае не воспринимайте такой оператор присваивания как уравнение!

number = int(input()) # например, 5
number = number + 1 # тогда здесь number становится равным 6
print(number)

Важно! Для конструкций вида number = number + 1 существует и сокращенная форма записи оператора присваивания: number += 1. Аналогично оператор x = x + y можно записать как x += y, оператор x = x * y — как x *= y, и так для любого из семи арифметических действий.

3. Сигнал остановки
Рассмотрим такую задачу: пользователь вводит числа. Пусть это будут цены на купленные в магазине товары, а наша программа — часть программного обеспечения кассового аппарата. Ввод "−1" — сигнал остановки. Нужно сосчитать сумму всех введенных чисел (сумму чека).
Поскольку требуется повторить нечто (ввод очередной цены) неизвестное количество раз, потребуется цикл while. Нам понадобится как минимум две переменные: price для цены очередного товара и total — для общей суммы.
Если бы мы знали точно, что пользователю надо купить ровно три товара, цикл (и ввод −1 как условие его прерывания) был бы не нужен. Тогда программа могла бы выглядеть так:

total = 0
price = float(input())
total = total + price
price = float(input())
total = total + price
price = float(input())
total = total + price
print('Сумма введённых чисел равна', total)

Обратите внимание: мы назвали переменные осмысленно. Это очень облегчит жизнь программисту, который будет читать наш код позже, даже если это будете вы сами неделю спустя. Однако интерпретатор Python к этому факту совершенно равнодушен. Чтобы значения переменных соответствовали названиям и тому смыслу, который мы в них закладываем, нужно поддерживать переменные в актуальном состоянии. И только вы, программист, можете это сделать.
С переменной price все относительно понятно: ее значение обновляется при считывании с клавиатуры на каждой итерации цикла, как это делалось во многих других задачах. total сначала равно нулю: до начала ввода цен их сумма, конечно, ноль. Однако значение переменной total устаревает каждый раз, когда пользователь вводит цену очередного товара. Поэтому нам нужно прибавить к значению total только что введенную цену, чтобы эта переменная по-прежнему обозначала сумму цен всех купленных товаров.
Если бы мы хотели сократить запись, можно было бы организовать цикл, который выполнился бы ровно три раза. Для этого нам потребуется переменная-счетчик, которая внутри цикла будет считать каждую итерацию цикла. А условием выхода обозначим выполнение нужного количества итераций:

count = 0
total = 0
while count < 3:
    price = float(input())
    total = total + price
    count = count + 1
print('Сумма введённых чисел равна', total)

Обратите внимание: total и count должны обнуляться до цикла.
Однако у нас в задаче количество товаров неизвестно, поэтому понадобится цикл до ввода сигнала остановки (−1). С учетом сказанного выше программа будет выглядеть так:

total = 0
print('Вводите цены; для остановки введите -1.')
price = float(input())
while price > 0:
    total = total + price # можно заменить на аналогичную запись
    # total += price00000000000000
    price = float(input())
print('Общая стоимость равна', total)

Подсчет количества элементов, удовлетворяющих условию
А теперь рассмотрим еще одну задачу.
Пользователь вводит целые числа. Ввод чисел прекращается, если введено число 0. Необходимо определить, сколько чисел среди введенных оканчивались на 2 и были кратны числу 4. Теперь нам надо проверять последовательность чисел.
Для каждого введенного числа надо делать проверку, соответствует ли оно условию. Если оно подходит под условие, увеличиваем счетчик таких чисел.
И уже после цикла, когда остановился ввод чисел, выводим результат — посчитанное количество нужных чисел.

count = 0
number = int(input())
while number != 0:
    if number % 10 == 2 and number % 4 == 0:
        count += 1
    number = int(input())
print('Количество искомых чисел:', count)

Обратите внимание: до цикла необходимо задать начальное значение для переменной count. Ведь когда придет первое подходящее под условие число, у нас count будет увеличиваться на 1 относительно предыдущего значения. А значит, это значение должно быть задано.
Давайте посмотрим, как будет работать эта программа для последовательности чисел: 12, 3, 32, 14, 0.
Поиск максимума и минимума: Очень часто в задачах приходится использовать различные статистические алгоритмы: поиск максимума, минимума, среднего значения, медианы и моды чисел, главный из которых — определение максимального и минимального значений на множестве данных.
Рассмотрим алгоритм в общем виде: Заведем отдельную переменную для хранения максимума и минимума. В качестве начального значения можно задать:
Заведомо малое для анализируемых данных значения, для максимума это будет совсем маленькое число: например, если мы вычисляем максимальный балл за экзамен, можно взять maximum = 0, тогда гарантированно произойдет замена максимума. Минимуму же, наоборот, присваивается заведомо большое значение
Первый элемент данных
В теле цикла каждый подходящий элемент данных обрабатывается операторами по принципу:
Если текущий элемент больше максимума, меняем максимум
Если текущий элемент меньше минимума, заменяем минимум
Рассмотрим пример. Витя анализировал список литературы и решил, что хочет начать с самой большой по объему книги. Напишем программу, которая поможет мальчику определить, сколько страниц ему предстоит прочитать. Витя последовательно вводит количество страниц каждой книги из списка, а окончанием ввода служит ввод любого отрицательного числа (или 0).

biggest_book = 0
n = int(input())
while n > 0:
    if n > biggest_book:
        biggest_book = n
    n = int(input())
print(biggest_book)

Так как книга не может содержать в себе 0 страниц, для значения максимума мы можем взять 0.
После этого Витя начинает вводить количество страниц: например, он вводит 148. 148 > 0 — условие цикла выполняется, и мы переходим к операции сравнения. На данном шаге 148 > 0, значит, biggest_book = 148. Снова считываем число.
Предположим, теперь введено 120. 120 > 0 — продолжаем работать в цикле. 120 > 148 — условие не выполняется, переходим к вводу новых данных, biggest_book все еще равен 148.
В этот раз мальчик ввел 486, мы заходим в цикл 486 > 148, производим замену biggest_book = 486. Продолжаем ввод. И так далее до тех пор пока не будет введено отрицательное число или 0.
При решении задачи мы можем использовать особенность языка Python 3.8 — моржовый оператор или, как его еще называют, «оператор-морж» (из за ассоциации обозначения оператора := c животным). Моржовый оператор позволяет присвоить значение переменной в условии if или while. Используя его, можно записать нашу программу следующим образом:

biggest_book = 0
while (n := int(input())) > 0:
    if n > biggest_book:
        biggest_book = n
print(biggest_book)

В этой программе значение переменной n задается один раз, в условии цикла, в отличие от ее предыдущей версии.

Цикл for

1. Именованные аргументы функции print
Мы уже пользовались тем, что функция print при выводе разделяет аргументы пробелами, а в конце переходит на новую строчку.
Часто это удобно. Но что если от этого нужно избавиться? В примере ниже пробелы появляются не только после двоеточий (что хорошо), но и перед запятой (что плохо).

measures = 7
cuts = 1
print('Количество отмеров:', measures, ', количество отрезов:', cuts)
# выведет: "Количество отмеров: 7 , количество отрезов: 1"

Необязательные именованные аргументы
Для такой тонкой настройки вывода у функции print существуют необязательные именованные аргументы — такие удобные инструменты бывают и у других функций, мы познакомимся с ними позже.
Обычно при вызове функции мы пишем имя функции, а затем в скобках ее аргументы через запятую. Стандартный способ сообщить функции, что и с какими аргументами делать (например, какой из аргументов функции print вывести первым, какой вторым и т. д.), — это передать аргументы в нужном порядке. Например, функция print выводит аргументы именно в том порядке, в котором их ей передали. Однако есть и другой способ — именованные аргументы. Чтобы при вызове функции передать ей именованный аргумент, нужно после обычных аргументов написать через запятую имя аргумента, знак = и значение аргумента.
sep и end: Функция print, наряду с другими аргументами, может (вместе или по отдельности) принимать два следующих аргумента: sep — разделитель аргументов (по умолчанию пробел) и end — то, что выводится после вывода всех аргументов (по умолчанию символ начала новой строки).
В частности, если end сделать пустой строкой, то print не перейдет на новую строчку, и следующий print продолжит вывод прямо на этой же строке.

print('При')
print('вет!')
# эти две строки кода выведут "При" и "вет!" на отдельных строках
print('При', end='')
print('вет!')  # эти две строки кода выведут "Привет!"
print('Раз', 'два', 'три')  # выведет "Раз два три"
print('Раз', 'два', 'три', sep='--')  # выведет "Раз--два--три"

Обратите внимание: знак = здесь не выполняет никакого присваивания, переменных end и sep не появляется.
PEP 8:Не используйте пробелы вокруг знака =, если он используется для обозначения именованного аргумента.
Правильно:
print('При', end='')
Неправильно:
print('При', end = '')

2. Специальные символы в строках
Можно задаться вопросом: как указать значение end по умолчанию — символ начала новой строчки? Ведь это специальный символ, который нельзя сделать частью строки, просто поместив его между кавычек, это вызовет ошибку.
Экранирующая последовательность
Если внутри кавычек встречается символ \ — обратная косая черта, обратный слеш, бэкслеш, он вместе с идущим после него символом образует экранирующую последовательность (escape sequence) и воспринимается интерпретатором как единый специальный символ.
В частности, \n — символ начала новой строки. Кроме того, \t — табуляция, \'  — кавычка, \\ — просто бэкслеш. Использование экранирующих последовательностей вместо специальных символов называется их экранированием.

print('восход\t07:15\nзакат\t22:03')
print('Предыдущая строка этой программы выглядит так:')
print('print(\'восход\\t07:15\\nзакат\\t22:03\')')

Таким образом, значения именованных аргументов функции print по умолчанию такие: print(..., sep=' ', end='\n').
Важно! При этом если приписать букву r перед открывающей строку кавычкой, бэкслеши будут считаться обычными символами.
А если открывать и закрывать строку не одной, а тремя кавычками подряд, внутри можно делать обычные переводы строки (внутри одинарных кавычек так делать нельзя).

print(r'\\\\\\\nnnnn <- забор, переходящий в низкую изгородь')
print('''Нужно сказать много важного.
Одной строки для этого мало.
Зато три - в самый раз.''')

3. Цикл for
Сегодня мы изучим еще один оператор цикла. Цикл for выполняет блок кода заданное количество раз.
Синтаксис

for ... in range(...):
    блок кода (тело цикла)

Как и у while, у цикла for есть заголовок, заканчивающийся двоеточием, и тело цикла, которое записывается с отступом в четыре пробела. В цикле вида for ... in range(...): вместо первого многоточия указывается какая-то переменная, которая на начальной итерации принимает значение 0, на следующей — 1, и так далее, до значения, указанного в range(...), само это значение переменная не принимает. Диапазон значений переменной-итератора от 0 включая и до значения, указанного в range(...), не включая его.
Вот программа, которая выводит на экран подряд (на отдельных строчках) целые числа от 0 (включительно) до n (не включительно).

n = int(input())
for i in range(n):
    print(i)

Range: Range означает «диапазон», то есть for i in range(n) читается как «для (всех) i в диапазоне от 0 (включительно) до n (не включительно)». Цикл выполняется n раз.
Давайте вспомним задачу, где мы три раза получали цены на товар и вычисляли общую цену товара.
Вот так мы ее записали через цикл while:

count = 0
total = 0
while count < 3:
    price = float(input())
    total = total + price
    count = count + 1
print('Сумма введённых чисел равна', total)

Теперь мы ее можем записать через цикл for, который будет выполняться три раза:
total = 0
for i in range(3):
    price = float(input())
    total = total + price
print('Сумма введённых чисел равна', total)

В данном случае переменная-счетчик изменяется сама в рамках заданных значений.
Запустите эту программу с отладчиком и пройдите ее пошагово. Можно поставить breakpoint на первую же строчку или начать выполнение программы кнопкой F7. Следите за тем, как меняется значение переменной i. Обратите внимание, что цикл for присваивает переменной i (она называется итератором цикла) значения (0, потом 1...), хотя нигде нет оператора присваивания = или его родственников типа +=.

4. Соглашения об именовании переменных
В программах, решающих абстрактные, математические задачи, допустимо называть переменные короткими и непонятными именами типа n или i. Однако этого лучше избегать. Кроме того, стоит соблюдать общепринятые договоренности: буквой n обычно обозначают количество чего-либо (например, итераций цикла). При этом если есть хоть какая-то определенность (например, речь идет о количестве автомобилей), то стоит и переменную назвать более понятно (например, cars). Буквами i и j (по-русски они традиционно читаются как «и» и «жи») обычно обозначают итераторы цикла for.
Еще один пример: программа, подсчитывающая сумму всех целых чисел, которые меньше данного.

n = int(input())
total = 0
for i in range(n):
    print('Рассматриваем число', i)
    total += i
    print('Промежуточная сумма равна', total)
print('Итоговая сумма всех этих чисел равна', total)

5. Начальное значение и шаг итератора в range
Однако это не все возможности цикла for.
Предположим, вам нужен цикл, выполняющийся 10 итераций. При этом нужно, чтобы итератор пробегал значения не подряд (0, 1, ..., 9), а, скажем, 10, 20, ..., 100. Конечно, с помощью уже известной нам конструкции for можно организовать цикл, в котором некая дополнительная переменная будет последовательно принимать именно такие значения (проверьте себя: как?).
Однако для этого есть и специальная встроенная в язык конструкция. В скобках после слова range можно записать не одно, а два или три числа. (Правда, очень похоже на функцию? Это не случайность, range — тоже функция, но об этом позже). Эти числа будут интерпретироваться как начальное значение итератора, конечное и его шаг (может быть отрицательным).
Если для range задано одно число, то итератор идет от 0 до заданного значения (не включая его).
Если задано два числа, то это начальное значение итератора и конечное.
Если задано три числа, то это не только начальное и конечное значение итератора, но и шаг итератора.

for i in range(1, 11):
    print(i)  # выведет на отдельных строчках числа
              # от 1 (включительно) до 11 (не включительно)
for i in range(1, 11, 2):
    print(i)  # выведет (на отдельных строчках) 1, 3, 5, 7, 9
for i in range(10, 0, -1):
    print(i)  # выведет 10, 9, ..., 1

6. Когда какой цикл использовать
Цикл while нужен, когда какой-то кусок кода должен выполниться несколько раз, причем заранее неизвестно, сколько именно
Цикл for нужен, когда какой-то кусок кода должен выполниться несколько раз, при этом известно сколько раз еще до начала цикла