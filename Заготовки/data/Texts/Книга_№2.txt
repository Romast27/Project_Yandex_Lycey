Знакомство со средой

1. Введение
Программа — список команд, то есть инструкций для компьютера: отобразить что-нибудь на экране, вычислить что-нибудь и т. д.
В вашем компьютере много разных программ. Программа-браузер показывает вам страницы в Интернете, программа-плеер проигрывает музыку, Word позволяет редактировать тексты, игры развлекают вас, вирусы мешают — и все это программы. Чтобы создать страницу на сайте в Интернете, которую получит и покажет ваш браузер (например, вашу страничку «ВКонтакте» или результаты поиска в Яндексе), компьютер, на котором работает этот сайт, часто тоже выполняет какую-то программу.
Есть разные способы записать программу. Однако наиболее удобная для компьютера форма записи в виде машинного кода неудобна для человека. Поэтому для составления программ придумали языки программирования.
Язык программирования
Язык программирования — набор строгих правил, согласно которым компьютер может понимать команды и выполнять их. Текст программы, написанной на любом языке программирования, называется программным кодом (или просто кодом).
Языки программирования бывают двух основных типов: компилируемые и интерпретируемые. Если программа написана на компилируемом языке (например, Pascal или C++), перед ее выполнением нужно сначала полностью проверить на некоторые ошибки и перевести в более понятную для компьютера форму. Это делает специальная программа — компилятор.
Если программа написана на интерпретируемом языке (например, JavaScript или Python), она не переводится целиком в машинный код, а специальная программа — интерпретатор — идет по коду, анализирует и выполняет каждую отдельную команду. Такой подход придает языку особую гибкость и простоту в написании программ.
Язык Python, который мы сейчас начнем изучать, разработал голландский программист Гвидо Ван Россум (Guido van Rossum) в 1991 году. Не подумайте, что язык назван в честь змеи-питона: Гвидо был большим фанатом британского комедийного сериала «Летающий цирк Монти Пайтона» (англ. Monty Python’s Flying Circus), и именно оттуда пришло название языка. В настоящее время в русском языке для обозначения используют два варианта — «Питон» и «Пайтон».
Python относится к интерпретируемым языкам программирования: чтобы запустить написанную на Python программу, нужен интерпретатор Python (его можно скачать с сайта python.org). Подробнее об установке языка Python смотрите в видеоинструкции к уроку.

2. Знакомство с IDE
Команды для интерпретатора можно писать в обычном текстовом редакторе (например, в «Блокноте»). Но чаще для этого пользуются специальной программой, которая называется средой разработки (англ. IDE, Integrated Development Environment). Среда разработки — тоже текстовый редактор, но с дополнительными возможностями. Например, она умеет сама находить на компьютере программу-интерпретатор и запускать одной кнопкой. Среда разработки, кроме того, форматирует написанный вами код, чтобы его удобно было читать, а иногда даже подсказывает, где вы допустили ошибку.
На первом этапе мы будем использовать среду разработки Wing IDE. Ее можно скачать с сайта разработчика, фирмы Wingware. В будущем вам может потребоваться более сложная и более богатая возможностями среда разработки. В этом случае мы рекомендуем использовать PyCharm — продукт российской фирмы JetBrains.
Ну что же, пора приступать к разработке программ. Для начала запустите среду разработки WingIDE. Давайте проверим настройки кодировок файлов. Эти настройки потребуются для корректной сдачи программ в тестирующую систему.
Зайдите в меню Edit → Preferences. Перейдите к категории Files. Для опции Default Encoding выберите значение Unicode (UTF-8) utf-8.
Зайдите в меню Edit → Preferences. Перейдите к категории Debugger → I/O. Для опции Debug I/O Encoding выберите значение Unicode (UTF-8) utf-8.
Примечание: на компьютерах с системой Mac OS вместо меню Edit необходимо открывать вкладку Wing 101 или Cmd + «,».
PEP 8
При оформлении программ мы будем пользоваться PEP 8 — Python Enhanced Proposal. Это документ, описывающий общепринятый (рекомендуемый) стиль написания программ на языке Python. Документ создан по рекомендациям Гвидо Ван Россума и Барри Уорсо, ознакомиться с материалами на русском языке можно, например, тут. В наших материалах мы будем отмечать рекомендации PEP 8 таким блоком.
Среды разработки могут помогать с форматированием по PEP 8. Для включения такой возможности в Wing IDE зайдите в меню Edit → Preferences. Перейдите к категории Editor → PEP 8. Для опции Auto-Reformat for PEP 8 выберите значение Lines After Edit.
Команда print()
А теперь изучим команду вывода на экран. Для вывода на экран используется команда print().

3. Команда print()
Внутри круглых скобок через запятую мы указываем то, что необходимо вывести на экран. Если это какой-то текст, указываем его внутри кавычек. Кавычки могут быть как одинарными, так и двойными. Главное, чтобы текст начинался и заканчивался кавычками одного типа. Команда print записывается только строчными буквами, другое написание недопустимо, так как в Python строчные и заглавные буквы различны.
Создайте в среде новый файл и напишите в нем команду вывода на экран слова «Привет!» Команда будет выглядеть так:

print('Привет!')

Обратите внимание: слова выделены разными цветами. В среде Wing IDE используется цветовое выделение синтаксиса. Все стандартные команды и функции выделяются синим и голубым цветом, фиолетовым или зеленым выделяются текстовые данные — строки, заключенные в кавычки.
Могут использоваться другие цветовые настройки — это зависит от версии, IDE. А может задаваться программистом в настройках среды.
PEP 8
Избегайте использования пробелов cразу перед открывающей скобкой, после которой начинается список аргументов функции.
Правильно:
print('Привет!')

Неправильно:
print ('Привет!')

Настало время запустить первую программу. Однако кнопка запуска Run  пока недоступна. Перед запуском необходимо сохранить файл на диск.
Вы будете писать много программ, только за первый год обучения их будет более 500, поэтому для удобства создавайте для каждого урока свою папку, в которой будете хранить программы этого урока, а сами файлы с программами называйте так, чтобы было понятно, о какой задаче идет речь. Назовите данный файл hello и сохраните его. Теперь стала доступна кнопка запуска. Запустите программу.

4. Тестирующая система
Вы только что написали свою первую программу. А сейчас вы сдадите свою первую задачу в тестирующую систему.
Измените свою программу так, чтобы она решала задачу «Приветствие». Запустите и проверьте ее. И, если она работает верно, сдавайте задание в тестирующую систему. Не забудьте сохранить новую программу в отдельном файле. Сейчас это кажется не очень важным, но потом, когда программ станет больше, а сами они длиннее и сложнее, привычка систематизировать материалы очень вам поможет. Чтобы не путаться, код какой программы в каком файле, именем может служить название задачи в тестирующей системе.
Написать или запустить неверную программу — не страшно. Что-то не понять — тоже не страшно. Даже опытные программисты иногда ошибаются и что-то не понимают. Поэтому в случае затруднений всегда смело задавайте вопросы и просите преподавателя вам помочь.
Ваша программа пока умеет только здороваться. Давайте сделаем так, чтобы она выводила две строчки с текстом. В первой строке «Привет, Яндекс!», а на второй — «Приятно познакомиться.». Для этого нам понадобится еще одна команда print. Эту команду нам обязательно надо написать с новой строки. Каждая новая команда пишется с новой строки! Сохраните программу с новым именем acquaintance, запустите и проверьте. И, если все правильно, сдавайте задачу «Знакомство» в тестирующую систему.
Когда сдадите задачу, попробуйте внести в свою программу ошибки: добавьте опечатку в слово print, уберите открывающую или закрывающую скобку, придумайте еще что-нибудь необычное. Обратите внимание: в консоли появляется сообщение, в котором есть слово Error. SyntaxError: invalid syntax часто означает именно забытую кавычку или скобку. Проведите небольшой эксперимент: если вы добавите опечатку в слово print, оно станет черным — редактор не узнает его и не понимает, что это команда.
Давайте теперь немного изменим нашу последнюю программу. Попробуйте заменить строчку print('Привет, Яндекс!') на строку print('Привет', 'Яндекс!'). Запустите и посмотрите, что будет выведено на экран. В этот раз мы внутри команды print указали две строки, заключенные в кавычки, но разделили эти строки между собой запятой. Как уже говорилось в начале урока, внутри круглых скобок через запятую указывается то, что нужно вывести на экран. В данном случае на экран выводятся две строки. Первая — «Привет», вторая — «Яндекс!» Эти строки пишутся в команде print через запятую, а появляются на экране через пробел. То есть запятая внутри команды заменяется на пробел при выводе на экран.
PEP 8
Обратите внимание: после запятой согласно стандарту PEP 8 обязательно нужно добавлять пробел.
Правильно:
print('Привет', 'Яндекс!')

Неправильно:
print('Привет','Яндекс!')

Выполнив программу, мы видим, что фраза «Привет Яндекс!» не соответствует требуемой. В ней не хватает запятой. Запятая должна быть выведена на экран, а это значит, что она должна оказаться внутри строки, заключенной в кавычки. Исправьте программу и добейтесь правильного вывода. Самостоятельно разбейте фразу «Приятно познакомиться.» на две строки, которые внутри команды print будут записываться через запятую.

5. Команда input()
Пока что все наши программы выводили на экран фразы, известные в момент написания кода. Но программы могут работать и с данными, которые станут известны только во время выполнения: например, их будет вводить пользователь с клавиатуры. Мы можем реализовать это так:

print('Как тебя зовут?')
name = input()
print('Привет,', name)

Запустите эту программу. Она выводит на экран строчку «Как тебя зовут?» и дальше ждет от пользователя ввода ответа на вопрос, ввода имени.
Введите имя. Запустите еще раз. Введите чужое имя.
Здесь используется команда input().
Команда input()
Она всегда пишется с круглыми скобками. Команда работает так: когда программа доходит до места, где есть input(), она ждет, пока пользователь введет строку с клавиатуры (ввод завершается нажатием клавиши Enter). Введенная строка подставляется на место input().
То есть, если вы ввели «Аня», программа дальше будет работать так, как будто на месте input() было написано «Аня».
Таким образом, input() получает от пользователя какие-то данные и в место вызова подставляет строковое значение, в нашем случае записывает его в качестве значения переменной name. Мы рассмотрим, что значит сохранить в значение переменной, а пока запомните:
если нужно, чтобы программа что-то печатала на экране и это увидел пользователь, — print. Если нужно, чтобы пользователь что-то напечатал с клавиатуры и чтобы программа могла использовать эти данные, — input().

6. Переменные
Команду name = input() можно считать так: «Подожди, пока пользователь введет какую-то строку и помести введенную строку в переменную name».
Попробуем разобраться, что это значит. Переменные имеют имя и значение.
Имя переменной
Имя переменной должно отражать ее назначение и может состоять из латинских букв, цифр и символа подчеркивания.
Имя не может начинаться с цифры.
PEP 8
Для именования переменных принято использовать стиль lower_case_with_underscores (слова из маленьких букв с подчеркиваниями).
Избегайте использовать такие символы, которые могут не однозначно трактоваться в различных шрифтах: это буква О (большая и маленькая) и цифра 0, буква I (большая и маленькая) и цифра 1. Нельзя использовать в качестве имени переменной и ключевые слова, которые существуют в языке.
В вышеописанном примере переменная содержит в себе имя пользователя, поэтому мы назвали ее name (имя). Обратите внимание: слово name не подсвечено никаким цветом — в Python это слово ничего не обозначает. Оно что-то значит только в этой программе и только потому, что мы употребили оператор присваивания. При этом интерпретатору совершенно неважно, что значит слово name в английском языке, и мы с тем же успехом могли использовать любое другое имя: например, user («пользователь») или просто n, или даже hello. За имена переменных отвечает программист, то есть вы.
Соблюдайте правило: если в переменной хранится приветствие, пусть она так и называется, если имя — пусть она и называется соответственно.
Значение переменной
Значение переменной — то, что сохраняет в себе переменная.
Знак «=» обозначает команду под названием «оператор присваивания». Оператор присваивания присваивает значение, которое находится справа от знака равно, переменной, которая находится слева от знака равно.
В нашем случае это то, что поместил в нее пользователь командой input(). Это текстовое значение — строка. То есть переменная сохраняет в себе строковое значение. Говорят, что переменная строкового типа.
PEP 8
Всегда окружайте оператор присваивания одним пробелом с каждой стороны:
Правильно:
bird = "Тук-тук"
Неправильно:
bird="Тук-тук"

Еще пример:
print('Какая твоя любимая еда?')
meal = input()
print('Да.', meal, '- это вкусно.')

Обратите внимание: интерпретатор ждет, что пользователь что-то введет с клавиатуры ровно столько раз, сколько команд input() встречается в программе. Каждый input() завершается нажатием Enter на клавиатуре.

print('Как тебя зовут?')
name = input()
print('Привет,', name)
print('А какая твоя любимая еда?')
meal = input()
print('Да.', meal, '- это вкусно.')

Мы задали значение переменной. И что же, оно никогда не меняется? Конечно, в двух разных программах могут быть переменные с одинаковыми названиями, но разными значениями. Но могут ли в пределах одной программы под одним именем быть разные значения?
Да! Оператор присваивания сообщает переменной то или иное значение независимо от того, была ли эта переменная введена раньше. Вы можете менять значение переменной, записав еще один оператор присваивания. Если у нас имеется переменная, мы можем делать с ее значением все что угодно — например, присвоить другой переменной:

hello = 'Здравствуйте.
hello2 = hello
print(hello2)

Итак, если вы хотите, чтобы у вас была переменная с каким-то именем и каким-то значением, нужно написать на отдельной строчке:
<имя переменной> = <значение переменной>
Как только эта команда выполнится, в программе появится указанная переменная с таким значением.
Помните: команды выполняются последовательно, в том же порядке, в котором они написаны.
А теперь смоделируем небольшой взлом программы.
Загрузите файл guessing_game.py. Это тоже программа на Python. Для начала просто запустите ее (двойным кликом). Как видите, это игра-угадайка. Шанс угадать невелик, у кого получится — тот везучий. Как бы облегчить выигрыш?
Теперь откройте эту программу в редакторе. Это делается не двойным кликом, а кликом правой кнопкой и выбором пункта Edit with Wing IDE (или Редактировать с помощью Wing IDE). Смысл некоторых строчек этой программы вы уже знаете. О других скоро узнаете или сможете догадаться.
Сейчас мы научимся жульничать в игре путем изменения этой программы. Конечно, можно было бы заменить всю программу единственной строчкой — поздравлением с победой. Но мы будем считать, что менять можно только одну строчку — ту, которая сейчас пуста. Мы можем вписать туда любую команду.
Мы знаем, что к тому моменту, когда выполнение программы доходит до пустой строчки, в переменной под названием planet лежит название загаданной планеты. Сделайте так, чтобы в этот момент оно выводилось прямо на экран, — тогда игроку останется лишь повторить название для победы (это потребуется вам в задаче «Взлом планетной угадайки»).
Эта задача проверяется преподавателем, поэтому для получения баллов необходимо, чтобы преподаватель проверил сданное решение.

7. Трассировка
Задача (для разбора). Предположим, у нас есть программа, которая входит в интерфейс сайта «Госуслуги» и служит для смены имени. Как будет работать эта программа, что она выведет при каком-либо пользовательском вводе?

print('Введите фамилию:')
surname = input()
print('Введите имя:')
name = input()
print(name, surname)
print('Введите новое имя:')
new_name = input()
print(name, surname)
print(new_name, name)
name = new_name
print(new_name, name)
print(name, surname)

Давайте немного изменим программу и посмотрим, что теперь получится.

print('Введите фамилию:')
surname = input()
print('Введите имя:')
name = input()
print(name, surname)
print('Введите новое имя:')
new_name = input()
old_name = name
name = new_name
print(new_name, old_name)
print(name, surname)

Если вы написали программу и не уверены в правильности ее написания, разберите, что она делает. Если не уверены, что все сделали правильно, — запустите и проверьте свои рассуждения.
Комментарии
Для удобства можно использовать комментарии, которые позволяют программисту делать для себя пометки в коде или делать часть кода не выполнимой, не видимой для интерпретатора.
Если вы начнете строчку со знака решетки #, интерпретатор Python будет игнорировать всю эту строчку. Программа будет выполняться так, как будто строчки нет. Такая строчка называется комментарием.
Комментарии нужны в двух случаях:
Когда нужно добавить в программу какую-то пометку для человека, который будет читать эту программу (например, см. третью строчку guessing_game).
Когда нужно убрать какую-то строчку кода, но удалять ее не хочется (например, потом ее, возможно, понадобится вернуть). Это называется «закомментировать» строчку.
PEP 8
«Встрочные» комментарии находятся в той же строке, что и инструкция. Они должны отделяться по крайней мере двумя пробелами от инструкции и начинаться с символа # и одного пробела.
Комментарии в строке с кодом не нужны и только отвлекают от чтения, если они объясняют очевидное.

Правильно:
x = x + 1  # компенсация границы

Неправильно:
x = x + 1  # увеличение на единицу
Если нужно закомментировать сразу несколько строчек подряд, не делайте это вручную. Выделите эти строчки и выберите Source → Toggle block comment (там же можно убрать комментирование).
Заметьте, что в конце guessing_game на отдельной строчке стоит знакомая команда input(). Зачем она нужна?
Ответ: когда запускаешь программу двойным кликом, окно с программой закрывается сразу, как только программа заканчивает работу. Если программа что-то выводит на экран в конце работы, пользователь этого не увидит. А так программа ждет, пока пользователь нажмет клавишу Enter. Конечно, он может что-то ввести, но это неважно — мы все равно никак не используем этот ввод. Попробуйте закомментировать последнюю строчку guessing_game и запустить программу из проводника двойным кликом.
Заметьте: если запустить программу, у которой в конце input(), из редактора Wing IDE, в конце ее работы придется лишний раз нажать Enter, хотя в этом и нет необходимости.
Попробуйте запустить программу hello или любую другую из своих старых программ двойным кликом — сначала в исходном виде, потом с input() в конце.



Условный оператор

1. Повторение
На прошлом уроке мы познакомились с переменными. Переменная имеет имя и значение. Имя переменной может начинаться только с буквы и включать в себя буквы, цифры и символ подчеркивания. Имя переменной должно отражать ее назначение.
Чтобы задать переменной значение, необходимо после знака равно (оператора присваивания) указать значение переменной.
Еще значение переменной можно получить из ввода. Для этого используем команду input(). В этом случае значение переменной задает пользователь.
2. Условный оператор
Условный оператор используется, когда некая часть программы должна быть выполнена, только если верно какое-либо условие. Для записи условного оператора используются ключевые слова if и else («если», «иначе»), двоеточие и  отступ в четыре пробела.

if условие:
    Действия, если условие верно
else:
    Действия, если условие неверно

PEP 8
Отступ в четыре пробела принят в сообществе Python (PEP 8). При этом программа может работать и при других вариантах, но читать ее будет неудобно. Пробелы — самый предпочтительный метод отступов.
Табуляция должна использоваться только для поддержки кода, написанного с отступами с помощью табуляции.
Python 3 запрещает смешивание табуляции и пробелов в отступах.
Рассмотрим пример:

print('Введите пароль:')
password = input()
if password == 'qwerty':
    print('Доступ открыт.')
else:
    print('Ошибка, доступ закрыт!')

Обратите внимание: в начале условного оператора if выполняется сравнение, а не присваивание. Разница вот в чем.
Сравнение
Сравнение — это проверка, которая не меняет значение переменной (в сравнении может вообще не быть переменных), а присваивание — команда, которая меняет значение переменной.
Для сравнения нужно использовать двойной знак равенства: ==.
Также заметьте, что после else никогда не пишется никакого условия.
Другой пример:

print('Представься, о незнакомец!')
name = input()
if name == 'Цезарь':
    print('Аве, Цезарь!')
else:
    print('Приветик.')

В качестве условия можно использовать и другие операции отношения:

< меньше
> больше
<= меньше или равно
>= больше или равно
== равно
!= не равно

PEP 8
Все операции отношения оформляются с помощью симметричных пробелов.

Правильно:
if bird == "Тук-тук":

Неправильно:
if bird=="Тук-тук":

Объекты любой однородной группы можно сравнивать между собой. Подумайте над тем, как можно сравнивать, например, строки.

3. Сложное условие. Логические операции
Иногда в условном операторе нужно задать сложное условие. Для этого можно использовать логические операции and («и»), or («или») и not («не»).
Чтобы задать одновременное выполнение двух условий, используем and («и»), если достаточно выполнения одного из двух вариантов (или обоих сразу) — используем or («или»), а если нужно убрать какой-то вариант — not («не»).
Приоритет выполнения операций:

1. not
2. and
3. or

Если нужно изменить приоритет операций или вы забыли правила, используйте скобки.
Например, вот так можно проверить, что оба условия выполнены:

print('Как называются первая и последняя буквы греческого алфавита?')
greek_letter_1 = input()
greek_letter_2 = input()
if greek_letter_1 == 'альфа' and greek_letter_2 == 'омега':
    print('Верно.')
else:
    print('Неверно.')

Ниже еще несколько примеров.

print('Как греки или римляне называли главу своего пантеона - бога грома?')
ancient_god = input()
if ancient_god == 'Зевс' or ancient_god == 'Юпитер':
    print('Верно.')
else:
    print('Неверно.')
print('Введите имена двух братьев из античных мифов и легенд.')
brother1 = input()
brother2 = input()
if brother1 == 'Ромул' and brother2 == 'Рем' or brother1 == 'Кастор' and (brother2 == 'Поллукс' or brother2 == 'Полидевк'):
    print('Верно.')
else:
    print('Неверно.')

Обратите внимание: если программу из предыдущего примера вставить в IDE Wing, часть кода условного оператора будет выходить за ограничительную красную черту среды.
PEP 8
По стандарту PEP 8 длина строки должна быть ограничена максимум 79 символами.
Есть несколько способов переноса длинных строк.
Использование подразумеваемых продолжений Python внутри круглых, квадратных и фигурных скобок: длинные строки могут быть разбиты на несколько строк, заключенных в скобки.
Использование символа ’\’ (обратный слеш, или бэкслеш) для обозначения места разрыва строки.
Мы будем использовать первый способ.
Если после перенесенной строки идет один или несколько вложенных операторов (например, мы переносим строку с условием в операторе if), отступ у перенесенной части должен быть на четыре пробела больше, чем у вложенного оператора.
Сделайте правильные отступы для перенесенной строки.
Тогда представленный выше программный код может быть записан так:

print('Введите имена двух братьев из античных мифов и легенд.')
brother1 = input()
brother2 = input()
if (brother1 == 'Ромул' and brother2 == 'Рем' or brother1 == 'Кастор'
        and (brother2 == 'Поллукс' or brother2 == 'Полидевк')):
    print('Верно.')
else:
    print('Неверно.')

Рассмотрим еще несколько примеров.

print('Введите любые два слова, но это не должны быть "белый" и "медведь" разом.')
word1 = input()
word2 = input()
if not (word1 == 'белый' and word2 == 'медведь'):
    print('Верно.')
else:
    print('Неверно.')

А теперь попробуйте решить задачи: «Елочка, гори», «Елочка-2», «Елочка-3».

4. Вложенные условия
Блок кода
В команде if при выполнении условия можно выполнять более одной команды. Для этого все их необходимо выделить отступом. Такая запись называется блоком кода. По отступам интерпретатор определяет, при выполнении каких условий какие команды исполнять. Аналогично можно делать и для команды else.

print('Представься, о незнакомец!')
name = input()
if name == 'Цезарь' or name == 'Caesar':
    print('Аве, Цезарь!')
    print('Слава императору!')
else:
    print('Приветик.')
    print('Погода сегодня хорошая.')
print('Засим - заканчиваем.')

Перед последней строчкой нет отступа, это означает, что она будет выполнена в конце работы программы в любом случае. А вот две предыдущие строчки будут выполнены, только если условие if окажется ложным.
Блоки кода в Python очень гибко устроены: внутри них можно писать любой другой код, в том числе условные операторы. Среди команд, которые выполняются, если условие if истинно («внутри if») или ложно («внутри else»), могут быть и другие условные операторы. Тогда команды, которые выполняются внутри этого внутреннего if или else, записываются с дополнительным отступом.
Изучите пример ниже. elif — это короткая запись для «else: if». Если не пользоваться короткой записью, if пришлось бы писать на отдельной строчке и с отступом (а все, что внутри этого if, — с дополнительным отступом). Это не очень удобно, и elif избавляет от такой необходимости.

print('Представься, о незнакомец!')
name = input()
if name == 'Цезарь' or name == 'Caesar':
    print('Аве, Цезарь!')
    print('В честь какого бога устроим сегодня празднество?')
    god = input()
    if god == 'Юпитер':
        print('Ура Громовержцу!')
    # если оказалось, что имя бога не 'Юпитер', то проверяем,
    # не равно ли оно строке 'Минерва'
    elif god == 'Минерва':
        print('Ура мудрой воительнице!')
    # следующая строка будет выполнена,
    # только если имя бога не 'Юпитер' и не 'Минерва'
    else:
        print('Бога по имени', god, 'мы не знаем, но слово Цезаря - закон.')
    # эта команда будет выполнена независимо от того,
    # какое имя бога ввёл пользователь, если только изначально
    # он представился Цезарем
    print('Слава императору!')
else:
    print('Приветик.')
    print('Погода сегодня хорошая.')
print('Засим - заканчиваем.')

А более простой вариант этой программы теперь попробуйте написать самостоятельно.

5. Операции над строками
Во всех примерах, которые мы рассматривали, переменные хранили строки. Мы вводили, выводили и хранили строки. Кроме уже описанных действий, строки еще можно складывать.
Давайте попробуем:

x = '10'
y = '20'
z = x + y
print(z)

PEP 8
И опять немного рекомендаций по оформлению (PEP 8): ставьте пробелы вокруг знаков операций (*, +, - и т. д.)

Правильно:
z = x + y

Неправильно:
z = x+y

В данной программе мы задали переменным x и y значение, переменной z присвоили значение результата сложения x и y.
Результатом выполнения программы будет строка 1020.
Конкатенация
Операция сложения для строк выполняет конкатенацию двух строк, то есть склеивает их содержимое вместе.
Например: операция «При» + «вет» в результате даст строку «Привет».
Обратите внимание: запись: x + y = z недопустима. Оператор присваивания ожидает слева переменную, которой надо присвоить значение, а в правой части находится значение или выражение, которое надо сначала вычислить, а затем присвоить.
Мы могли сократить нашу программу и написать в таком виде:

x = '10'
y = '20'
print(x + y)

Результат будет такой же, проверьте. Оператор print() сначала вычислил значение выражения x + y, а потом вывел на экран полученное значение.
А еще такой результат можно получить вот таким образом:

print('10' + '20')

Дублирование
Для строк также можно выполнять умножение. Умножать можно строку на число или число на строку. Операция называется дублирование. В результате нее начальная строка будет повторена заданное количество раз.
Например: 3 * "20" то же, что и "20" * 3 и , результат будет 202020 и в том, и в другом случае.
Примеры использования:

x = '10'
y = '20'
print(x * 2 + y * 3)

Что будет на экране после запуска такой программы?

6. Команда in
Теперь рассмотрим новую команду для работы со строками — команду in.
Команда in
Команда in позволяет проверить, что одна строка находится внутри другой.
Например: строка «на» находится внутри строки «сложная задача».
В таком случае обычно говорят, что одна строка является подстрокой для другой.

text = input()
if 'хорош' in text and 'плох' not in text:
    print('Текст имеет положительную эмоциональную окраску.')
elif 'плох' in text and 'хорош' not in text:
    print('Текст имеет отрицательную эмоциональную окраску.')
else:
    print('Текст имеет нейтральную или смешанную эмоциональную окраску.')

Первое условие окажется истинным, например, для строк «все хорошо» и «какой хороший день», но не для «ВсЕ ХоРоШо» и не для «что-то хорошо, а что-то и плохо». Аналогично второе условие окажется истинным для строк «все плохо», «плохое настроение» и т. д.


Простые встроенные функции

1. Повторение
На прошлом уроке мы рассмотрели условный оператор, который позволяет выполнять различные ветки кода в зависимости от заданных условий. Научились составлять сложные условия при помощи операций not, and и or.
2. Типы данных
Пока единственным типом данных, с которым мы работали, были строки. Теперь нам предстоит рассмотреть целые и вещественные числа. У каждого элемента данных, который встречается в программе, есть свой тип. (В случае с Python более правильный термин — «класс объекта», но об этом мы будем говорить гораздо позже).
Например, «привет» — это строка, а вот 15.3 — это число (дробное). Даже если данные не записаны прямо в программе, а получаются откуда-то еще, у них есть совершенно определенный тип. Например, на место input() всегда подставляется строка, а 2 + 2 даст именно число 4, а не строку "4".
Пользователь может ввести с клавиатуры какие-то цифры, но в результате input() вернет строку, состоящую из этих цифр. Если мы попытаемся, например, прибавить к этой строке 1, получим ошибку.
Давайте попробуем это сделать:

a = input()
print(a + 1)

Сохраните и запустите программу. Введите любое число и посмотрите, что получится.
Ошибка возникнет потому, что в переменную а у нас попадает строка, а в функции print мы пытаемся сложить эту строку из переменной а и число 1. Исправьте программу так, чтобы она работала.
А если нам надо работать с числами? Мы пока будем рассматривать целые и вещественные числа.
Когда речь идет о числовых данных, они записываются без кавычек.
А для вещественных чисел, чтобы отделить дробную часть от целой, используют точку.
На прошлом занятии мы складывали две строки:

print('10' + '20')

И получали результат — строку "1020".
Давайте попробуем в этом примере убрать кавычки. В таком случае речь пойдет уже не о строках, а о двух целых числах.
И результатом функции print(10 + 20) будет целое число 30.
А если мы попробуем сложить два вещественных числа print(10.0 + 20.0), результатом будет вещественное число 30.0.
Попробуйте предположить, что будет, если сложить вещественное число и целое число print(10.0 + 20). Почему?
3. Операции над числами
Мы выполняли сложение двух чисел внутри функции print, но мы можем переменным давать нужные значения и выполнять действия над переменными.
Давайте напишем программу, которая задаст нужные значения двум переменным (10 и 20), потом вычислит их сумму, положит это значение в третью переменную и выведет на экран полученный результат. Допишите начальные строки, чтобы программа решала поставленную задачу:

...
print(summ)

Обратите внимание: если в качестве имени переменной для суммы взять sum, оно выделяется цветом. Это означает, что такое имя знакомо среде и принадлежит какой-то функции, в качестве имени переменной его лучше не использовать.
Как складывать два числа, мы научились. Еще числа можно вычитать, умножать, делить, возводить в степень, получать целую часть от деления и остаток от деления нацело. Давайте разберем эти операции на примерах.

print(30 - 10)
print(30.0 - 10)
print(3 * 3)

С вычитанием и умножением все понятно, они аналогичны сложению.
Возведение в степень обозначается двумя звездочками **, которые должны записываться без разделителей.

print(9 ** 2)

Обратите внимание: результат деления всегда вещественный, даже если мы делим два целых числа, которые делятся нацело.

print(10 / 2)

Попробуйте поделить на 0. Посмотрите, как будет выглядеть ошибка деления на 0.
4. Целочисленное деление
Для реализации целочисленного деления существуют два действия: деление нацело и остаток от деления нацело. Получение целой части от деления обозначается как удвоенный знак деления, а остатка от деления нацело — %.
Давайте подробнее разберем эти операции. Что будет выведено в результате этих действий?

print(10 // 3, 10 % 3)
print(10 // 5, 10 % 5)
print(10 // 11, 10 % 11)

Допустим, вам известны результаты a // b, a % b и число b, напишите формулу, как найти число a?
Давайте проверим вашу формулу:

a = 10
b = 3
print(…А сюда напишем формулу…)

Обратите внимание на порядок выполнения действий в вашей формуле. Целочисленное деление имеет тот же приоритет, что и обычное деление, значит, будет выполняться раньше, чем вычитание и сложение. Для изменения приоритета выполнения операций используются скобки, все так же, как в математике.
А теперь, немного разобравшись с этими операциями, попробуйте предположить, что выведется на экран после выполнения следующего куска кода:

print(10 // 3, 10 % 3)
print(-10 // 3, -10 % 3)

Определите, что будет выведено на экран?

a = 4
b = 15
c = b / 5 * 3 - a
print(c)

5. Приоритет операций
Мы уже изучили несколько типов операций в языке Python:
Операцию присваивания (=)
Операции сравнения (==, !=, >, <, >=, <=)
Арифметические операции (+, -, *, /, %, //)
Логические операции (not, and, or)

Есть и другие, с которыми познакомимся позднее. Все эти операции могут использоваться совместно в довольно сложных конструкциях, поэтому нужно помнить о приоритете операций и в случае необходимости менять его при помощи скобок.
Итак, приоритет выполнения операций в Python от высшего (выполняется первой) до низшего:
Возведение в степень (**).
Унарный минус (-). Используется для получения, например, противоположного числа.
Умножение, деление (* /, %, //).
Сложение и вычитание (+ -).
Операции сравнения (<=, <, >, >=).
Операции равенства (==, !=).
Логические операции (not, and, or).
Операции присваивания (=, +=, -=, *= и т. д.)

PEP 8
По обе стороны бинарной операции нужно обязательно ставить по одному пробелу. Но операции, состоящие из двойных символов (<=, >=, ==, !=, -=, +=), пробелами не разделяются.
6. Простейшие функции
С действиями над числами определились, осталось разобраться, как получать числа из ввода. Здесь нам поможет важное новое понятие — функция. В математике функция из одного числа (или даже нескольких) делает другое.
Функция
В программировании (и в Python, в частности) функция — это сущность, которая из одного (или даже нескольких) значений делает другое. При этом она может еще и выполнять какие-то действия.
Например, есть функция модуля у = |x|, аналогично в Python есть функция y = abs(x).
Но функции в Python необязательно принимают только числа.
Для того чтобы вводить числа с клавиатуры и потом работать с ними, необходимо найти функцию, которая из строки делает число. И такие функции есть!
Тип данных целых чисел в Python называется int, дробных чисел — float.
Одноименные функции принимают в качестве аргумента строку и возвращают число, если в этой строке было записано число (иначе выдают ошибку):

a = input()
b = int(a)
print(b + 1)

Или можно написать даже так:
a = int(input())

что будет означать — «получи строку из ввода, сделай из нее целое число и результат помести в переменную а».

И тогда предыдущая программа может быть записана в виде:
a = int(input())
print(a + 1)

Но можно сократить код еще, написав вот так:
print(int(input()) + 1)

Функция int может быть применена и для получения целого числа из вещественного, в таком случае дробная часть будет отброшена (без округления).
Например, print(int(20.5 + 34.1)) выдаст на экран число 54, хотя, если сложить эти числа и не отправлять их в функцию int, результат будет 54.6.
В Python cуществует огромное количество различных функций, мы будем знакомиться с ними постепенно. Так, например, для строки можно определить еще и ее длину.
Длина строки
Длина строки — это количество символов в строке.
Для определения длины строки используется стандартная функция Python len().
На примере функции len разберемся с основными понятиями, связанными с использованием функций. Изучите код:

word = input()
length = len(word)
print('Вы ввели слово длиной', length, 'букв.')

Использование в программе функции называется «вызов функции». Он устроен так: пишем имя функции — len, а затем в скобках те данные, которые мы передаем этой функции, чтобы она что-то с ними сделала. Такие данные называются аргументами.
В нашем примере данные в скобках должны быть строкой. Мы выбрали в качестве данных значение переменной word, которое пользователь до этого ввел с клавиатуры. То есть значение переменной word выступает здесь в роли аргумента. А функция len выдает длину этой строки. Если пользователь ввел, например, «привет», word оказывается равно строке «привет», и на место len(word) подставляется длина строки «привет», то есть 6.
Обратите внимание: каждый раз, когда мы пишем имя переменной (кроме самого первого раза — в операции присваивания слева от знака равно), вместо этого имени интерпретатор подставляет значение переменной.
Точно так же на место вызова функции (то есть имени функции и ее аргументов в скобках) подставляется результат ее работы, это называется возвращаемое значение функции.
Таким образом, функция len возвращает длину своего аргумента. input — тоже функция (отсюда скобки), она может работать, не принимая никаких аргументов, а может в качестве аргумента принимать сообщение, которое надо вывести перед ожиданием пользовательского ввода. Но всегда считывает строку с клавиатуры и возвращает ее.
print — тоже функция, она не возвращает никакого осмысленного значения, зато выводит свои аргументы на экран. Эта функция может принимать не один аргумент, а сколько угодно. Несколько аргументов одной функции следует разделять запятыми.
На самом деле функция сама по себе — это фактически небольшая программа, но об этом позже.
Функции безразлично происхождение значений, которые ей передали в качестве аргумента. Это может быть значение переменной, результат работы другой функции или записанное прямо в коде значение:

print('Это слово длиной', len('абракадабра'), 'букв.')

Обратите внимание: в предыдущем примере значение переменной word вообще никак не изменилось от вызова функции len. C другой стороны, вызов функции может стоять где угодно, необязательно сразу класть возвращаемое значение в переменную.
Как существует функция int, которая пытается сделать из того, что ей передали, целое число, так же существует и функция str, которая возвращает строку из тех данных, что в нее передали.

print(str(10) + str(20)) # выведет '1020'
print(int('10') + int('20')) # выведет 30

Каждый раз, когда вы пишете программу, важно понимать, какой тип имеет каждое значение и каждая переменная.

7. Обмен значениями переменных
Мы изучили операции с различными типами данных.
Давайте попробуем написать программу, которая поменяет местами содержимое переменных а и b. Пусть есть такой код:

a = 3
b = 5
...
...
print(a)
print(b)

Что надо вписать в пропущенные места, чтобы в а лежало 5, а в b лежало 3? При этом числами 3 и 5 пользоваться нельзя.
Как один из вариантов можно использовать дополнительную переменную:

a = 3
b = 5
с = a
a = b
b = c
print(a)
print(b)

А теперь попробуйте написать вариант без дополнительной переменной, через сумму двух чисел.
Но нам повезло, что мы изучаем язык Python, потому что он и поддерживает более простой вариант записи:

a = 3
b = 5
a, b = b, a
print(a)
print(b)

Значения переменных, которые расположены справа от знака «присвоить», в указанном порядке помещаются в переменные слева, в порядке их указания.
Так, используя множественное присваивание, можно задавать нескольким переменным одно значение:

a = b = c = 5



Цикл while
Сегодня мы научимся повторять заданные действия несколько раз. Для этого существуют операторы циклов. Мы разберем оператор цикла while. Он выполняет блок кода, пока истинно какое-то условие.
Напомним, условный оператор if проверяет условие и, в зависимости от того, истинно оно или ложно, выполняет либо не выполняет следующий записанный с отступом блок. После этого программа в любом случае выполняется дальше (там еще может быть elif или else, но сути это не меняет).
1. Цикл while
Оператор while («пока») тоже проверяет условие и тоже, в случае его истинности, выполняет следующий блок кода (тело цикла). Однако после выполнения этого блока кода выполняется не то, что идет после него, а снова проверяется условие, записанное после while.
Ведь при выполнении тела цикла значения каких-то переменных могли измениться — в результате условие цикла может уже не быть истинным. Если условие все еще истинно, тело цикла выполняется снова. Как только условие цикла перестало выполняться (в том числе если оно с самого начала не было выполнено), программа идёт дальше — выполняются команды, записанные после тела цикла.
Условие цикла записывается, как и для if: с помощью операций отношения (>, >=, <, <=, !=, ==). Cложные условия можно составлять с помощью логических операций not, and, or.
Действия, расположенные в теле цикла (блок кода), записываются со смещением вправо на четыре пробела относительно начала слова while. Переменные, входящие в условие, должны на момент проверки условия цикла иметь значения.

while условие:
    блок кода (тело цикла)

Важно!Один шаг цикла (выполнение тела цикла) еще называют итерацией.
Используйте цикл while всегда, когда какая-то часть кода должна выполниться несколько раз, причем невозможно заранее сказать, сколько именно.
Давайте посмотрим программу, в которой цикл будет выполняться, пока не введут число, меньшее или равное 0:

number = int(input())
while number > 0:
    print('Вы ввели положительное число! Вводите дальше.')
    number = int(input())
    print('Так-так, что тут у нас...')
print('Вы ввели отрицательное число или ноль. Всё.')

Разберемся, как будет работать эта программа.
Сначала выполняется первая строчка: number = int(input()) — пользователь вводит целое число. (Мы предполагаем, что пользователь действительно ввел число, и программа не вылетела с ошибкой.) Предположим, он ввел число 10. Оно записано в переменной number.
Выполняется вторая строчка: while number > 0: — «пока number > 0» — здесь проверяется, выполнено ли условие number > 0. Поскольку мы предположили, что number в этот момент равно 10, тогда условие выполнено, поэтому дальше выполняется блок, записанный с отступом, — тело цикла.
Третья строчка программы выводит на экран строку, тут все понятно.
Четвертая строчка вновь считывает с клавиатуры число и сохраняет его в переменную number. Пусть пользователь ввел 2.
Когда выполнение программы доходит до конца тела цикла, происходит возврат к заголовку цикла (второй строчке программы) и повторная проверка условия. Поскольку 2 > 0, снова выполняется тело цикла.
Третья строчка снова выводит на экран сообщение, четвертая строчка снова считывает число (пусть это будет число 3), пятая строчка снова выводит на экран сообщение...
Закончив тело цикла, опять проверяем условие в заголовке. number равно 3, 3 > 0, поэтому продолжаем.
Третья строчка опять выводит на экран сообщение, четвертая строчка опять считывает число. Пусть теперь это будет −1. Обратите внимание: переменная number на каждой итерации цикла приобретает новое значение! Пятая строчка опять выводит на экран сообщение...
Вновь вернувшись на вторую строчку, получаем, что −1 > 0 — ложно. Поэтому цикл завершается, тело цикла больше не выполняется, прыгаем сразу на следующую после цикла строчку программы — шестую. Она выводит последнее сообщение.
Все.

2. Составной оператор присваивания
Напомним, что в операторе присваивания одно и то же имя переменной может стоять и справа (в составе какого-то выражения), и слева. В этом случае сначала вычисляется правая часть со старым значением переменной, после чего результат становится новым значением этой переменной. Ни в коем случае не воспринимайте такой оператор присваивания как уравнение!

number = int(input()) # например, 5
number = number + 1 # тогда здесь number становится равным 6
print(number)

Важно! Для конструкций вида number = number + 1 существует и сокращенная форма записи оператора присваивания: number += 1. Аналогично оператор x = x + y можно записать как x += y, оператор x = x * y — как x *= y, и так для любого из семи арифметических действий.

3. Сигнал остановки
Рассмотрим такую задачу: пользователь вводит числа. Пусть это будут цены на купленные в магазине товары, а наша программа — часть программного обеспечения кассового аппарата. Ввод "−1" — сигнал остановки. Нужно сосчитать сумму всех введенных чисел (сумму чека).
Поскольку требуется повторить нечто (ввод очередной цены) неизвестное количество раз, потребуется цикл while. Нам понадобится как минимум две переменные: price для цены очередного товара и total — для общей суммы.
Если бы мы знали точно, что пользователю надо купить ровно три товара, цикл (и ввод −1 как условие его прерывания) был бы не нужен. Тогда программа могла бы выглядеть так:

total = 0
price = float(input())
total = total + price
price = float(input())
total = total + price
price = float(input())
total = total + price
print('Сумма введённых чисел равна', total)

Обратите внимание: мы назвали переменные осмысленно. Это очень облегчит жизнь программисту, который будет читать наш код позже, даже если это будете вы сами неделю спустя. Однако интерпретатор Python к этому факту совершенно равнодушен. Чтобы значения переменных соответствовали названиям и тому смыслу, который мы в них закладываем, нужно поддерживать переменные в актуальном состоянии. И только вы, программист, можете это сделать.
С переменной price все относительно понятно: ее значение обновляется при считывании с клавиатуры на каждой итерации цикла, как это делалось во многих других задачах. total сначала равно нулю: до начала ввода цен их сумма, конечно, ноль. Однако значение переменной total устаревает каждый раз, когда пользователь вводит цену очередного товара. Поэтому нам нужно прибавить к значению total только что введенную цену, чтобы эта переменная по-прежнему обозначала сумму цен всех купленных товаров.
Если бы мы хотели сократить запись, можно было бы организовать цикл, который выполнился бы ровно три раза. Для этого нам потребуется переменная-счетчик, которая внутри цикла будет считать каждую итерацию цикла. А условием выхода обозначим выполнение нужного количества итераций:

count = 0
total = 0
while count < 3:
    price = float(input())
    total = total + price
    count = count + 1
print('Сумма введённых чисел равна', total)

Обратите внимание: total и count должны обнуляться до цикла.
Однако у нас в задаче количество товаров неизвестно, поэтому понадобится цикл до ввода сигнала остановки (−1). С учетом сказанного выше программа будет выглядеть так:

total = 0
print('Вводите цены; для остановки введите -1.')
price = float(input())
while price > 0:
    total = total + price # можно заменить на аналогичную запись
    # total += price00000000000000
    price = float(input())
print('Общая стоимость равна', total)

Подсчет количества элементов, удовлетворяющих условию
А теперь рассмотрим еще одну задачу.
Пользователь вводит целые числа. Ввод чисел прекращается, если введено число 0. Необходимо определить, сколько чисел среди введенных оканчивались на 2 и были кратны числу 4. Теперь нам надо проверять последовательность чисел.
Для каждого введенного числа надо делать проверку, соответствует ли оно условию. Если оно подходит под условие, увеличиваем счетчик таких чисел.
И уже после цикла, когда остановился ввод чисел, выводим результат — посчитанное количество нужных чисел.

count = 0
number = int(input())
while number != 0:
    if number % 10 == 2 and number % 4 == 0:
        count += 1
    number = int(input())
print('Количество искомых чисел:', count)

Обратите внимание: до цикла необходимо задать начальное значение для переменной count. Ведь когда придет первое подходящее под условие число, у нас count будет увеличиваться на 1 относительно предыдущего значения. А значит, это значение должно быть задано.
Давайте посмотрим, как будет работать эта программа для последовательности чисел: 12, 3, 32, 14, 0.
Поиск максимума и минимума: Очень часто в задачах приходится использовать различные статистические алгоритмы: поиск максимума, минимума, среднего значения, медианы и моды чисел, главный из которых — определение максимального и минимального значений на множестве данных.
Рассмотрим алгоритм в общем виде: Заведем отдельную переменную для хранения максимума и минимума. В качестве начального значения можно задать:
Заведомо малое для анализируемых данных значения, для максимума это будет совсем маленькое число: например, если мы вычисляем максимальный балл за экзамен, можно взять maximum = 0, тогда гарантированно произойдет замена максимума. Минимуму же, наоборот, присваивается заведомо большое значение
Первый элемент данных
В теле цикла каждый подходящий элемент данных обрабатывается операторами по принципу:
Если текущий элемент больше максимума, меняем максимум
Если текущий элемент меньше минимума, заменяем минимум
Рассмотрим пример. Витя анализировал список литературы и решил, что хочет начать с самой большой по объему книги. Напишем программу, которая поможет мальчику определить, сколько страниц ему предстоит прочитать. Витя последовательно вводит количество страниц каждой книги из списка, а окончанием ввода служит ввод любого отрицательного числа (или 0).

biggest_book = 0
n = int(input())
while n > 0:
    if n > biggest_book:
        biggest_book = n
    n = int(input())
print(biggest_book)

Так как книга не может содержать в себе 0 страниц, для значения максимума мы можем взять 0.
После этого Витя начинает вводить количество страниц: например, он вводит 148. 148 > 0 — условие цикла выполняется, и мы переходим к операции сравнения. На данном шаге 148 > 0, значит, biggest_book = 148. Снова считываем число.
Предположим, теперь введено 120. 120 > 0 — продолжаем работать в цикле. 120 > 148 — условие не выполняется, переходим к вводу новых данных, biggest_book все еще равен 148.
В этот раз мальчик ввел 486, мы заходим в цикл 486 > 148, производим замену biggest_book = 486. Продолжаем ввод. И так далее до тех пор пока не будет введено отрицательное число или 0.
При решении задачи мы можем использовать особенность языка Python 3.8 — моржовый оператор или, как его еще называют, «оператор-морж» (из за ассоциации обозначения оператора := c животным). Моржовый оператор позволяет присвоить значение переменной в условии if или while. Используя его, можно записать нашу программу следующим образом:

biggest_book = 0
while (n := int(input())) > 0:
    if n > biggest_book:
        biggest_book = n
print(biggest_book)

В этой программе значение переменной n задается один раз, в условии цикла, в отличие от ее предыдущей версии.



Цикл for

1. Именованные аргументы функции print
Мы уже пользовались тем, что функция print при выводе разделяет аргументы пробелами, а в конце переходит на новую строчку.
Часто это удобно. Но что если от этого нужно избавиться? В примере ниже пробелы появляются не только после двоеточий (что хорошо), но и перед запятой (что плохо).

measures = 7
cuts = 1
print('Количество отмеров:', measures, ', количество отрезов:', cuts)
# выведет: "Количество отмеров: 7 , количество отрезов: 1"

Необязательные именованные аргументы
Для такой тонкой настройки вывода у функции print существуют необязательные именованные аргументы — такие удобные инструменты бывают и у других функций, мы познакомимся с ними позже.
Обычно при вызове функции мы пишем имя функции, а затем в скобках ее аргументы через запятую. Стандартный способ сообщить функции, что и с какими аргументами делать (например, какой из аргументов функции print вывести первым, какой вторым и т. д.), — это передать аргументы в нужном порядке. Например, функция print выводит аргументы именно в том порядке, в котором их ей передали. Однако есть и другой способ — именованные аргументы. Чтобы при вызове функции передать ей именованный аргумент, нужно после обычных аргументов написать через запятую имя аргумента, знак = и значение аргумента.
sep и end: Функция print, наряду с другими аргументами, может (вместе или по отдельности) принимать два следующих аргумента: sep — разделитель аргументов (по умолчанию пробел) и end — то, что выводится после вывода всех аргументов (по умолчанию символ начала новой строки).
В частности, если end сделать пустой строкой, то print не перейдет на новую строчку, и следующий print продолжит вывод прямо на этой же строке.

print('При')
print('вет!')
# эти две строки кода выведут "При" и "вет!" на отдельных строках
print('При', end='')
print('вет!')  # эти две строки кода выведут "Привет!"
print('Раз', 'два', 'три')  # выведет "Раз два три"
print('Раз', 'два', 'три', sep='--')  # выведет "Раз--два--три"

Обратите внимание: знак = здесь не выполняет никакого присваивания, переменных end и sep не появляется.
PEP 8:Не используйте пробелы вокруг знака =, если он используется для обозначения именованного аргумента.
Правильно:
print('При', end='')
Неправильно:
print('При', end = '')

2. Специальные символы в строках
Можно задаться вопросом: как указать значение end по умолчанию — символ начала новой строчки? Ведь это специальный символ, который нельзя сделать частью строки, просто поместив его между кавычек, это вызовет ошибку.
Экранирующая последовательность
Если внутри кавычек встречается символ \ — обратная косая черта, обратный слеш, бэкслеш, он вместе с идущим после него символом образует экранирующую последовательность (escape sequence) и воспринимается интерпретатором как единый специальный символ.
В частности, \n — символ начала новой строки. Кроме того, \t — табуляция, \'  — кавычка, \\ — просто бэкслеш. Использование экранирующих последовательностей вместо специальных символов называется их экранированием.

print('восход\t07:15\nзакат\t22:03')
print('Предыдущая строка этой программы выглядит так:')
print('print(\'восход\\t07:15\\nзакат\\t22:03\')')

Таким образом, значения именованных аргументов функции print по умолчанию такие: print(..., sep=' ', end='\n').
Важно! При этом если приписать букву r перед открывающей строку кавычкой, бэкслеши будут считаться обычными символами.
А если открывать и закрывать строку не одной, а тремя кавычками подряд, внутри можно делать обычные переводы строки (внутри одинарных кавычек так делать нельзя).

print(r'\\\\\\\nnnnn <- забор, переходящий в низкую изгородь')
print('''Нужно сказать много важного.
Одной строки для этого мало.
Зато три - в самый раз.''')

3. Цикл for
Сегодня мы изучим еще один оператор цикла. Цикл for выполняет блок кода заданное количество раз.
Синтаксис

for ... in range(...):
    блок кода (тело цикла)

Как и у while, у цикла for есть заголовок, заканчивающийся двоеточием, и тело цикла, которое записывается с отступом в четыре пробела. В цикле вида for ... in range(...): вместо первого многоточия указывается какая-то переменная, которая на начальной итерации принимает значение 0, на следующей — 1, и так далее, до значения, указанного в range(...), само это значение переменная не принимает. Диапазон значений переменной-итератора от 0 включая и до значения, указанного в range(...), не включая его.
Вот программа, которая выводит на экран подряд (на отдельных строчках) целые числа от 0 (включительно) до n (не включительно).

n = int(input())
for i in range(n):
    print(i)

Range: Range означает «диапазон», то есть for i in range(n) читается как «для (всех) i в диапазоне от 0 (включительно) до n (не включительно)». Цикл выполняется n раз.
Давайте вспомним задачу, где мы три раза получали цены на товар и вычисляли общую цену товара.
Вот так мы ее записали через цикл while:

count = 0
total = 0
while count < 3:
    price = float(input())
    total = total + price
    count = count + 1
print('Сумма введённых чисел равна', total)

Теперь мы ее можем записать через цикл for, который будет выполняться три раза:
total = 0
for i in range(3):
    price = float(input())
    total = total + price
print('Сумма введённых чисел равна', total)

В данном случае переменная-счетчик изменяется сама в рамках заданных значений.
Запустите эту программу с отладчиком и пройдите ее пошагово. Можно поставить breakpoint на первую же строчку или начать выполнение программы кнопкой F7. Следите за тем, как меняется значение переменной i. Обратите внимание, что цикл for присваивает переменной i (она называется итератором цикла) значения (0, потом 1...), хотя нигде нет оператора присваивания = или его родственников типа +=.

4. Соглашения об именовании переменных
В программах, решающих абстрактные, математические задачи, допустимо называть переменные короткими и непонятными именами типа n или i. Однако этого лучше избегать. Кроме того, стоит соблюдать общепринятые договоренности: буквой n обычно обозначают количество чего-либо (например, итераций цикла). При этом если есть хоть какая-то определенность (например, речь идет о количестве автомобилей), то стоит и переменную назвать более понятно (например, cars). Буквами i и j (по-русски они традиционно читаются как «и» и «жи») обычно обозначают итераторы цикла for.
Еще один пример: программа, подсчитывающая сумму всех целых чисел, которые меньше данного.

n = int(input())
total = 0
for i in range(n):
    print('Рассматриваем число', i)
    total += i
    print('Промежуточная сумма равна', total)
print('Итоговая сумма всех этих чисел равна', total)

5. Начальное значение и шаг итератора в range
Однако это не все возможности цикла for.
Предположим, вам нужен цикл, выполняющийся 10 итераций. При этом нужно, чтобы итератор пробегал значения не подряд (0, 1, ..., 9), а, скажем, 10, 20, ..., 100. Конечно, с помощью уже известной нам конструкции for можно организовать цикл, в котором некая дополнительная переменная будет последовательно принимать именно такие значения (проверьте себя: как?).
Однако для этого есть и специальная встроенная в язык конструкция. В скобках после слова range можно записать не одно, а два или три числа. (Правда, очень похоже на функцию? Это не случайность, range — тоже функция, но об этом позже). Эти числа будут интерпретироваться как начальное значение итератора, конечное и его шаг (может быть отрицательным).
Если для range задано одно число, то итератор идет от 0 до заданного значения (не включая его).
Если задано два числа, то это начальное значение итератора и конечное.
Если задано три числа, то это не только начальное и конечное значение итератора, но и шаг итератора.

for i in range(1, 11):
    print(i)  # выведет на отдельных строчках числа
              # от 1 (включительно) до 11 (не включительно)
for i in range(1, 11, 2):
    print(i)  # выведет (на отдельных строчках) 1, 3, 5, 7, 9
for i in range(10, 0, -1):
    print(i)  # выведет 10, 9, ..., 1

6. Когда какой цикл использовать
Цикл while нужен, когда какой-то кусок кода должен выполниться несколько раз, причем заранее неизвестно, сколько именно
Цикл for нужен, когда какой-то кусок кода должен выполниться несколько раз, при этом известно сколько раз еще до начала цикла